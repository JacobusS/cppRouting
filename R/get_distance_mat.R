#' Compute all shortest distance between origin and destination nodes.
#' 
#' @param Graph  An object generated by cppRouting::makegraph() function.
#' @param from A vector of one or more vertices from which distances are calculated (origin).
#' @param to A vector of one or more vertices (destination).
#' @param allcores Logical. If TRUE, all cores are used.
#' @return Matrix of shortest distances.
#' @note get_distance_matrix() recursively perform Dijkstra algorithm for each 'from' nodes.


get_distance_matrix<-function(Graph,from,to,allcores=FALSE){
  if (any(is.na(from))) stop("NAs are not allowed in origin/destination nodes")
  if (any(is.na(to))) stop("NAs are not allowed in origin/destination nodes")
  from<-as.character(from)
  to<-as.character(to)
  allnodes<-c(from,to)
  if (sum(allnodes %in% Graph$dict$ref)<length(allnodes)) stop("Some nodes are not in the graph")
  
  from_id<-Graph$dict$id[match(from,Graph$dict$ref)]
  to_id<-Graph$dict$id[match(to,Graph$dict$ref)]
  
  
  if (allcores==TRUE){
    numWorkers <- parallel::detectCores()
    cl <- parallel::makeCluster(numWorkers, type = "PSOCK")
    parallel::clusterEvalQ(cl = cl,library("cppRouting"))
    chunks <- parallel::splitIndices(length(from), ncl = numWorkers)
    mylist<-lapply(chunks,function(x) from_id[x])
    #mylist2<-lapply(chunks,function(x) to_id[x])
    res<-parallel::clusterMap(cl,Dijkstra_mat,dep=mylist,
                              MoreArgs = list(arr=to_id,gfrom=Graph$data$from,gto=Graph$data$to,gw=Graph$data$dist,NbNodes=Graph$nbnode))
    parallel::stopCluster(cl)
    res<-do.call(rbind,res)
    
  }
  else res<-Dijkstra_mat(Graph$data[,1],Graph$data[,2],Graph$data[,3],Graph$nbnode,from_id,to_id)
  
  rownames(res)<-from
  colnames(res)<-to
  return(res)
}
